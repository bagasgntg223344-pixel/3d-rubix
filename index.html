<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Rubik's Cube - GENESIS</title>
  <style>
    :root{
      --size: 60px;   /* size of each small cube */
      --gap: 6px;     /* gap between stickers */
      --cube-size: calc(var(--size) * 3 + var(--gap) * 2);
      --persp: 900px;
    }
    html,body{height:100%;margin:0;background:#0b1020;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
    .wrap{height:100%;display:flex;gap:20px;align-items:center;justify-content:center;padding:20px;box-sizing:border-box}
    .stage{
      width:500px;height:500px;display:flex;align-items:center;justify-content:center;
      perspective: var(--persp);
    }
    .scene{
      width:var(--cube-size);height:var(--cube-size);
      transform-style:preserve-3d;position:relative;transition:transform 300ms ease;
      cursor:grab;
    }

    .cubelet{
      position:absolute;width:var(--size);height:var(--size);
      transform-style:preserve-3d;left:50%;top:50%;margin-left:calc(-1 * var(--size) / 2);margin-top:calc(-1 * var(--size)/2);
      transition: transform 300ms ease;
    }

    .face{
      position:absolute;width:calc(var(--size) - 4px);height:calc(var(--size) - 4px);left:2px;top:2px;
      display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;
      backface-visibility:hidden;border-radius:4px;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.15);
    }

    /* face positions */
    .f_front{transform:translateZ(calc(var(--size) / 2));}
    .f_back{transform:rotateY(180deg) translateZ(calc(var(--size) / 2));}
    .f_right{transform:rotateY(90deg) translateZ(calc(var(--size) / 2));}
    .f_left{transform:rotateY(-90deg) translateZ(calc(var(--size) / 2));}
    .f_up{transform:rotateX(90deg) translateZ(calc(var(--size) / 2));}
    .f_down{transform:rotateX(-90deg) translateZ(calc(var(--size) / 2));}

    /* sticker colors (standard-ish) */
    .c_white{background:#ffffff}
    .c_yellow{background:#ffeb3b}
    .c_red{background:#e53935}
    .c_orange{background:#ff9800}
    .c_blue{background:#1e88e5}
    .c_green{background:#43a047}
    .c_black{background:#111}

    /* UI */
    .controls{display:flex;flex-direction:column;gap:10px}
    .row{display:flex;gap:6px}
    button{padding:8px 10px;border-radius:8px;border:0;background:#1f2937;color:#fff;cursor:pointer}
    button:active{transform:scale(0.98)}
    .info{max-width:360px;font-size:14px;line-height:1.3;color:#cbd5e1}

    footer{position:fixed;right:16px;bottom:12px;color:#94a3b8;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <div id="scene" class="scene" tabindex="0"></div>
    </div>

    <div class="controls">
      <div class="row">
        <button onclick="doMove('U')">U</button>
        <button onclick="doMove("U'")">U'</button>
        <button onclick="doMove('D')">D</button>
        <button onclick="doMove("D'")">D'</button>
      </div>
      <div class="row">
        <button onclick="doMove('L')">L</button>
        <button onclick="doMove("L'")">L'</button>
        <button onclick="doMove('R')">R</button>
        <button onclick="doMove("R'")">R'</button>
      </div>
      <div class="row">
        <button onclick="doMove('F')">F</button>
        <button onclick="doMove("F'")">F'</button>
        <button onclick="doMove('B')">B</button>
        <button onclick="doMove("B'")">B'</button>
      </div>

      <div class="info">
        <strong>Petunjuk:</strong>
        <ul>
          <li>Tekan dan seret pada kubus untuk memutar tampilan (rotate view).</li>
          <li>Tombol U/D/L/R/F/B akan memutar sisi kubus (tanpa animasi fisik, hanya mengubah warna stiker untuk menyederhanakan).</li>
          <li>U' artinya U counter-clockwise (kebalikan arah).</li>
        </ul>
      </div>
    </div>
  </div>

  <footer>3D Rubik's Cube â€” simple demo (HTML/CSS/JS)</footer>

  <script>
    /* Basic 3x3x3 model: coordinates x,y,z in {-1,0,1}
       Face naming: Up (y=1) = white, Down (y=-1)=yellow, Front (z=1)=red,
       Back (z=-1)=orange, Right (x=1)=blue, Left (x=-1)=green
    */

    const scene = document.getElementById('scene');
    const SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--size'));
    let rotation = {x: -30, y: -30};

    // data model: map key 'x,y,z' => stickers {U,D,F,B,R,L}
    const cube = new Map();

    function keyOf(x,y,z){return `${x},${y},${z}`}

    function initialStickerFor(x,y,z){
      return {
        U: y===1 ? 'white' : 'black',
        D: y===-1 ? 'yellow' : 'black',
        F: z===1 ? 'red' : 'black',
        B: z===-1 ? 'orange' : 'black',
        R: x===1 ? 'blue' : 'black',
        L: x===-1 ? 'green' : 'black'
      }
    }

    // create cubelets
    for(let x=-1;x<=1;x++) for(let y=-1;y<=1;y++) for(let z=-1;z<=1;z++){
      const stickers = initialStickerFor(x,y,z);
      cube.set(keyOf(x,y,z), {x,y,z,stickers});
    }

    function buildScene(){
      scene.innerHTML='';
      for(const cell of cube.values()){
        const el = document.createElement('div');
        el.className = 'cubelet';
        el.dataset.coords = keyOf(cell.x,cell.y,cell.z);
        const tx = cell.x * (SIZE + 6);
        const ty = -cell.y * (SIZE + 6);
        const tz = cell.z * (SIZE + 6);
        el.style.transform = `translate3d(${tx}px, ${ty}px, ${tz}px)`;

        // create 6 faces
        const faces = {
          F:['f_front','F'],B:['f_back','B'],R:['f_right','R'],L:['f_left','L'],U:['f_up','U'],D:['f_down','D']
        };
        for(const [code,[cls,prop]] of Object.entries(faces)){
          const f = document.createElement('div');
          f.className = `face ${cls}`;
          const c = cell.stickers[code];
          f.classList.add('c_' + c);
          el.appendChild(f);
        }

        scene.appendChild(el);
      }
      updateSceneRotation();
    }

    function updateSceneRotation(){
      scene.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`;
    }

    // simple drag to rotate
    let dragging=false,last={x:0,y:0};
    scene.addEventListener('pointerdown', (e)=>{dragging=true;scene.style.cursor='grabbing';last={x:e.clientX,y:e.clientY}});
    window.addEventListener('pointerup', ()=>{dragging=false;scene.style.cursor='grab'});
    window.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - last.x; const dy = e.clientY - last.y;
      rotation.y += dx * 0.4; rotation.x += dy * 0.4; last={x:e.clientX,y:e.clientY}; updateSceneRotation();
    });

    // Moves: we'll implement sticker permutation for each face
    // Helper: get cells that lie on a face
    function layerCoords(face){
      switch(face){
        case 'U': return [...cube.values()].filter(c=>c.y===1);
        case 'D': return [...cube.values()].filter(c=>c.y===-1);
        case 'F': return [...cube.values()].filter(c=>c.z===1);
        case 'B': return [...cube.values()].filter(c=>c.z===-1);
        case 'R': return [...cube.values()].filter(c=>c.x===1);
        case 'L': return [...cube.values()].filter(c=>c.x===-1);
      }
    }

    // rotate array of 9 cells clockwise on their face - permute stickers accordingly
    // We'll map positions in a 3x3 grid. For simplicity we compute new sticker values by mapping positions.
    function rotateFaceStickers(face, ccw=false){
      const layer = layerCoords(face);
      // map coords to 2D grid: u and v axes depend on face
      const posMap = new Map();
      for(const c of layer){
        let u,v;
        if(face==='U' || face==='D') { u = c.x; v = c.z; }
        if(face==='F' || face==='B') { u = c.x; v = -c.y; }
        if(face==='R' || face==='L') { u = c.z; v = -c.y; }
        posMap.set(`${u},${v}`, c);
      }
      // function to rotate coordinates clockwise: (u,v) -> (v,-u)
      function rot(u,v){return [v,-u];}

      const newStickers = new Map();
      for(const [k,c] of posMap.entries()){
        const [u,v] = k.split(',').map(Number);
        const [nu,nv] = ccw ? rot(rot(rot(u,v))) : rot(u,v); // ccw = three clockwise
        const target = posMap.get(`${nu},${nv}`);
        // For the face itself, rotate stickers among the face orientations
        // We will only permute the stickers that are on the moving face and also the adjacent stickers on edge pieces
        // Simpler: create deep copy of stickers for the target cell
        newStickers.set(keyOf(target.x,target.y,target.z), JSON.parse(JSON.stringify(c.stickers)));
      }

      // Now assign new stickers to those cells, but we need to rotate the face sticker orientation
      // For simplicity, after moving sticker sets between cubelets we also rotate the sticker faces within each cubelet
      // so that the face that corresponds to the moving face keeps being on that face.

      // Helper to rotate sticker faces inside a cubelet for a given outer face
      function rotateCellStickersForFace(stickersObj, faceKey, cw=true){
        // For each face movement type we must remap adjacent face stickers. This is a simplified approach:
        // We'll rotate only the four stickers around the corner for the face itself: (U,R,D,L) mapping depends on face.
        // To keep things readable we will handle each face using explicit mapping of orientations.
        const s = {...stickersObj};
        let map;
        if(faceKey==='U') map = {F:'R',R:'B',B:'L',L:'F'};
        if(faceKey==='D') map = {F:'L',L:'B',B:'R',R:'F'};
        if(faceKey==='F') map = {U:'L',L:'D',D:'R',R:'U'};
        if(faceKey==='B') map = {U:'R',R:'D',D:'L',L:'U'};
        if(faceKey==='R') map = {U:'F',F:'D',D:'B',B:'U'};
        if(faceKey==='L') map = {U:'B',B:'D',D:'F',F:'U'};
        const out = {...s};
        for(const [k,v] of Object.entries(map)){
          out[cw ? v : k] = s[k];
        }
        // ensure the moved face itself rotates (but color stays on that face)
        out[faceKey] = s[faceKey];
        return out;
      }

      // Apply new stickers
      for(const [k,stickersCopy] of newStickers.entries()){
        // rotate orientation inside the cubelet
        const rotated = rotateCellStickersForFace(stickersCopy, face, !ccw);
        const obj = cube.get(k);
        obj.stickers = rotated;
      }

      // re-render faces
      refreshCubeFaces();
    }

    function refreshCubeFaces(){
      for(const el of scene.querySelectorAll('.cubelet')){
        const k = el.dataset.coords;
        const obj = cube.get(k);
        // update face classes: remove c_ classes then add new
        for(const f of el.querySelectorAll('.face')){
          f.className = 'face ' + f.className.split(' ').slice(1).join(' ');
        }
        // assign colors
        const clsList = ['f_front','f_back','f_right','f_left','f_up','f_down'];
        const props = ['F','B','R','L','U','D'];
        for(let i=0;i<clsList.length;i++){
          const f = el.querySelector('.' + clsList[i]);
          const color = obj.stickers[props[i]] || 'black';
          // clear existing c_ classes
          f.classList.remove('c_white','c_yellow','c_red','c_orange','c_blue','c_green','c_black');
          f.classList.add('c_' + color);
        }
      }
    }

    // Move parsing
    function doMove(m){
      // m like "U" or "U'"
      let face = m[0];
      const ccw = m.length>1 && m[1]==="'";
      rotateFaceStickers(face, ccw);
    }

    // wire buttons safely (some onclicks included earlier used quotes escaping; ensure global functions exist)
    window.doMove = doMove;

    buildScene();
  </script>
</body>
</html>
